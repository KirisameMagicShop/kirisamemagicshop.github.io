+++
title = "一个抽象的 binary addition 算法"
author = "LdBeth"
date = 2019-11-18T16:34:00+08:00
tags = ["算法", "APL", "二进制"]
license = "转自[知乎](https://zhuanlan.zhihu.com/p/92381693)"
+++
![Header](v2-ab78974f11ac5d246038b7f47a3f1c15_1440w.image.png)

````apl
∇R←DECODE N
  R←2⊥N
∇

∇R←X ENCODE N
  R←(X⍴2)⊤N
∇

∇R←ENCODE32 N
  R←(32⍴2)⊤N
∇

∇R←ENCODE64 N
  R←(64⍴2)⊤N
∇

⍝ example
      ⎕←A←ENCODE64 865940890845960854
0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 1 1 0 1 1 1 1 1 0 1 1
      0 1 0 1 1 0 1 1 1 1 0 1 1 0 1 0 1 0 0 0 0 0 0 0
      DECODE A
8.659408908E17 ⍝ GG
````

正常情況下都会这么用 loop 写吧

````apl
∇R←A ADD B;C
  ⍝ BINARY ADDITION
  →NOTEST/BEGIN
  DERR∧/(A=A=1)∧B=B=1
BEGIN:
  ⍝ RESET OVERFLOW
  OVERFLOW←0
LOOP:A←A+B
  ⍝ FIND CARRY
  C←2=A
  →(0=+/C)/END
  A[C/⍳⍴C]←0
  ⍝ CHECK OVERFLOW
  OVERFLOW←OVERFLOW∨1=''⍴C
  B←(⍴C)↑1↓C
  →LOOP
END:
  R←A
∇
````

说白了就是进位法。

不过发现了一个规律沒有

````apl
      A←1 0 0 1 0 1 1 0 1 1 1 0 1 1 1 1
      B←1 0 1 0 1 1 0 0 0 0 1 0 0 0 0 1
      A+B
2 0 1 1 1 2 1 0 1 1 2 0 1 1 1 2
      A ADD B
0 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0
````

单个的 "2" 会变成 "10"，"12" 变成 "100"，"1112" 会变成 "10000"，"22" 则是 "110"。

这样看來根本不用 loop 麻。

````apl
      C
1 0 0 1 1 2 0 2 0 1 1 1 2
      1 1 0 1 0 0 1 1 1 1 0 0 0⊂C
┌─┬───┬─────┬─┬─┬─┬───────┐
│1│0 0│1 1 2│0│2│0│1 1 1 2│
└─┴───┴─────┴─┴─┴─┴───────┘
      Z←C>0
      Z
1 0 0 1 1 1 0 1 0 1 1 1 1
      (1⌽Z)-Z
¯1 0 1 0 0 ¯1 1 ¯1 1 0 0 0 0
      (¯1⌽Z)-Z
0 1 0 ¯1 0 0 1 ¯1 1 ¯1 0 0 0
      |(¯1⌽Z)-Z
0 1 0 1 0 0 1 1 1 1 0 0 0
      1,1↓|(¯1⌽Z)-Z
1 1 0 1 0 0 1 1 1 1 0 0 0
      (1,1↓|(¯1⌽Z)-Z)⊂C
┌─┬───┬─────┬─┬─┬─┬───────┐
│1│0 0│1 1 2│0│2│0│1 1 1 2│
└─┴───┴─────┴─┴─┴─┴───────┘
      ⌽¨(1,1↓|(¯1⌽Z)-Z)⊂C
┌─┬───┬─────┬─┬─┬─┬───────┐
│1│0 0│2 1 1│0│2│0│2 1 1 1│
└─┴───┴─────┴─┴─┴─┴───────┘
      A ADD B
1 0 1 0 0 0 1 0 1 0 0 0 0
      ⊃¨⌽¨(1,1↓|(¯1⌽Z)-Z)⊂C
1 0 2 0 2 0 2
      2=⊃¨⌽¨(1,1↓|(¯1⌽Z)-Z)⊂C
0 0 1 0 1 0 1
      K←⌽¨(1,1↓|(¯1⌽Z)-Z)⊂C
      2=⊃¨K
0 0 1 0 1 0 1
      (2=⊃¨K)/K
┌─────┬─┬───────┐
│2 1 1│2│2 1 1 1│
└─────┴─┴───────┘
      {(⍴⍵)⍴0}¨(2=⊃¨K)/K
┌─────┬─┬───────┐
│0 0 0│0│0 0 0 0│
└─────┴─┴───────┘
      Z←{(⍴⍵)⍴0}¨(2=⊃¨K)/K
      Z
┌─────┬─┬───────┐
│0 0 0│0│0 0 0 0│
└─────┴─┴───────┘
      K
┌─┬───┬─────┬─┬─┬─┬───────┐
│1│0 0│2 1 1│0│2│0│2 1 1 1│
└─┴───┴─────┴─┴─┴─┴───────┘
      K[⍸2=⊃¨K]←Z
      K
┌─┬───┬─────┬─┬─┬─┬───────┐
│1│0 0│0 0 0│0│0│0│0 0 0 0│
└─┴───┴─────┴─┴─┴─┴───────┘
      ∊K
1 0 0 0 0 0 0 0 0 0 0 0 0
````

于是有 version1

````apl
∇R←A ADDK B;C;B;T;K
  C←A+B
  N←C>0
  K←⌽¨(1,1↓|(¯1⌽N)-N)⊂C
  T←2=⊃¨K
  K[⍸T]←{(⍴⍵)⍴0}¨T/K
  T←(⍴T)↑1↓T
  K[⍸T]←{1,((⍴⍵)-1)⍴0}¨T/K
  K←∊⌽¨K
  R←K
∇
````

试一试

````apl
      A ADDK B
1 0 1 0 0 0 1 0 1 0 0 0 0 ⍝ seems ok
1 1 1 ADDK 1 1 1      
0 0 0
````

GG, WTF?

````apl
      A←B ← 1 1 1
      A+B
2 2 2
      C←A+B
      K←⌽¨(1,1↓|(¯1⌽N)-N←C>0)⊂C
      K
┌─────┐
│2 2 2│
└─────┘
````

額⋯⋯

说明 2 要額外做 partition。

那么干脆就一开始先 reverse 好了

于是最后版本 

````apl
∇R←A ADD B;C;N;I
  C←⌽A+B
  N←C>0
  R←((C=2)∨1,1↓|(¯1⌽N)-N)⊂C ⍝ Partition
  I←2=⊃¨R ⍝ Find pattern "1*2"
  R[⍸I]←{(⍴⍵)⍴0}¨I/R ⍝ substitution
  OVERFLOW←''⍴⌽I
  I←(-⍴I)↑¯1↓I ⍝ carry
  R[⍸I]←{1,((⍴⍵)-1)⍴0}¨I/R
  R←⌽∊R
∇
````

试试

````apl
      1 1 1 ADD 1 1 1
1 1 0
      OVERFLOW
1
````

∇
