+++
title = "命运之轮"
author = "圆角骑士魔理沙"
date = 2018-04-16T11:37:00+08:00
tags = ["编程语言", "编程语言史"]
license = "CC BY-SA 4.0"
+++
我最初学编程，应该也就是2010年左右的事情吧。

当时啥也不会，就会在C++吧水贴。

在那，听说过了有一个很厉害很潮流的东西，叫做C++11，有什么叫concept跟module的东西，好像挺厉害的样子。

当时，在clang上就可以用C++11了，只不过这两功能还没有，就有auto, lambda, constexpr 不知道有没有（记不清了），也很好了。

[时间快进到现在，这两功能还是没加进去。](https://www.zhihu.com/question/56943731)

不过C++厨们可以稍稍放心，我今天不是来黑C++的。

这固然是C++的悲剧，不过也是所有语言的悲剧。

  


如果去看历史，去看看一个个语言的发展，我们会发现一个规律：

<strong>语言/语言家族的发展，是不停的扩大，直到无法支撑自身的重量而倒下为止。</strong>

  


让我们跳到1958。

ALGOL。

只要大家说计算机历史，就一定要说ALGOL。

因为这可以说是一切的开端。也是一门伟大的语言。

做Algol相关的work的图灵奖得主，足足有6个：John Backus，Alan Perlis，Peter Naur，John McCarthy，Edsger W. Dijkstra，Tony Hoare。还有无冕之王，Peter Landin跟John Reynold。

但是，为何这么成功的语言，却默默无名？因为错在了下一步。

在1960后，ALGOL推出了ALGOL 58，ALGOL 60，还有各种方言后，大家开始慢慢懂该怎么设计语言，实现编译器了。BNF，Recursion，Continuation，Stack，都慢慢被大家发明发现，慢慢熟悉。大家也开始发现了ALGOL 60没做好跟没有做的东西。

于是，1962起，大家开始发明一门新的，叫ALGOL X的语言，旨在把这些问题修好。从1962起讨论，一直到1965，变成一个draft。高兴的ALGOL厨把这叫做ALGOL W，并且等着用了。一切就差一些小修小补了。

就跟物理学大厦就剩下两朵乌云一样。

快进半年。另外一个ALGOL W的draft被奉上。情况不容乐观。

本来说好的三个月，跳票成了半年不说，draft变得更厚更长，问题反而越来越多。于是说在等三个月，我们再修修。

明明说三月，三月后又三月，三月后又三月，都快一年了。

拖了9个月后，在1968年尾，一个叫ALGOL W的，连设计者也不爱的怪兽产生了。

自此，ALGOL被命运之轮碾过。

  


故事的另一个主角，则知名得多。CPL。

这是1963，离悲剧还远得很，这时候大家都已自己是ALGOL方言为荣。

CPL就是一个ALGOL方言，旨在做更底层的ALGOL。

语言的设计也不算很复杂，唯一的问题就是不知道为啥，编译器死活写不出来。

于是，1967，有人在想，为何我们不把CPL简化点？这样就能做出编译器来了。

然后就出现了BCPL。同年，BCPL的编译器也被实现了。

两年后，为了把BCPL放上微型机，再次简化，出现了B。

同时间，B的一些问题被发现，效率也不够高，于是一个差不多的语言开始被设计，C。

而在C设计过程中，1970年，CPL的编译器终于面世。

命运之轮碾压过ALGOL，再碾压过CPL，碾压一次不够再碾压一次，BCPL，最后出了B，然后造就了C。最大赢家。

之后的，就是历史。

  


不过，这不是结束。也不是结束的开始。顶多是开始的结束。

还记得最开头的C++吗？没错，命运之轮怎么会放过C。

在C++后，为了简化，出现了JAVA，旨在消除C++的各种复杂性-比如不区分unsigned啊，自动管理内存啊，只有Class啊-只不过，到了最后，还是照样该变大变大。自动管理内存的确比手动简单，但是JVM确变成一个怪兽。就连unsigned这种小东西，[也回到语言中了。](https://www.zhihu.com/question/39596383/answer/82267124)屠龙的勇士，必成恶龙。

另外一边，PERL崩溃之后诞生的Python也一样，，不知道怎么的，就加入了optional static typing。。。说好的only one way呢？Simplicity呢？

  


专门搞PL的人别偷笑，Scala就不说了，Haskell也一样，GHC无比复杂，连RecursiveDo都能水一篇[170页的Paper](https://pdfs.semanticscholar.org/20ab/57bf6d14d6a08a950b015d17af5f41b1b22b.pdf)，有一个minimal core，也不能解决这问题。也别以为Macro能解决问题-R6RS总共有187页，其中，有90页是语言定义。被称为怪兽的ALGOL W也就265页，实在差不了多少。ALGOL 60呢？17页。ALGOL 58则只有15页。不过R7RS倒是还行，只有77页。当然，这是以丢掉向后兼容性为代价的。

  


有没有语言试图挑战这命运之轮？

有。Scheme，Python，都壮士断腕，丢掉了向后兼容性。自己不丢，别人就会给你丢。

Go也算是，Rob Pike活了60年，啥大风大浪没见过，尤其是Google的Build Server再也撑不起他们的C++，当然知道复杂度乃洪水猛兽-要不然为啥死撑不肯加generic。

不过这几个付出的代价不少-不是兼容性就是限制自己发展。对于语言设计者来说，这是个绕不开的问题。

  


回到最初。为什么C++的concept module老是跳票，总共跳了9年？

还记得ALGOL W有多少页吗？265。至于C++17，1600多。6个ALGOL W，100个ALGOL 58。能让人大呼卧槽的数字。Java标准700页，加上JVM，也有1300页。

  


于是隔几天，我跟朋友吃饭的时候提起，卧槽，现在的编程语言复杂度都变成鬼了，100个ALGOL。这么复杂，怎么设计怎么写编译器。

我那在nvidia实习的朋友听了，不以为然的说了声，哦。直到我过了半年，上了门计算机架构的课，才明白为什么他没有被震惊到。

  


其实PL的复杂度爆炸还算好的了。


